import JavaBasics;
import SpringCloudStreamBasics;
import MeshBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamYaml(Configuration config, FileArtifact target, mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes) extends MeshBasics {

    def function(sequenceOf(MeshElement) nodes) {
        println(nodes);
        String result = "";
        for (MeshElement elt: nodes) {
            if (result.length() > 0) {
                result = result + ";";
            }
            result = result + generateDataMethods(elt);
        }        
        result;
    }
    
    def sources() {
        if (ingestors.size() > 0) {
            String sources = "";
            for (String i: ingestors.keys()) {
                if (sources.length() > 0) {
                    sources = sources + ";";
                }
                sources = sources + i;
            }
            "source: ${sources}"
        } 
    }
    
    def nativeEnc() {
        'producer: 
            useNativeEncoding: true'
    }
    
    def bindings(mapOf(MeshElement, setOf(MeshConnector)) mappedMesh) {
        for (MeshElement elt: mappedMesh.keys()) {
            String eltMet = generateDataMethods(elt);
            Boolean doOut;
            if (!asyncIngestors.containsKey(eltMet)) {
                doOut = true;
            } else {
                doOut = !asyncIngestors.get(eltMet); // out for synchronous, in for asynchronous
            }
            if (doOut) {
            '${eltMet}-out-0:
                    destination: ${eltMet}'
            ''
            } else { // automatic serialization fails (sometimes) in spring cloud stream 3.1.1 when connected to consumer
            '${eltMet}-in-0:
                    producer:
                        useNativeEncoding: true'
            ''
            }
            for (MeshConnector conn: mappedMesh.get(elt)) {
                MeshInnerElement next = conn.next;
                String nextMeth = generateDataMethods(next);
                '${nextMeth}-in-0:
                    destination: ${eltMet}
                '
            }
        }
    }
    
    def generateSourceMethod(MeshSource src, String type, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 

    def generateAsyncProcessorInMethod(MeshProcessor proc, String type, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 

    def generateSyncProcessorMethod(MeshProcessor proc, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 
    
    def generateSinkMethod(MeshSink sink, String type, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 

    def protocolConfig(IIPEcosphere config) {
        protocolConfig(config.transportProtocol);
    }

    def protocolConfig(TransportProtocol protocol) {
        ''
    }

    def protocolConfig(TransportProtocolAMQP protocol) {
        'amqp:
            port: ${protocol.port}
            user: ${protocol.user}
            password: ${protocol.password}'
    }

    def protocolConfig(TransportProtocolMQTTv3 protocol) {
        'mqtt:
            port: ${protocol.port}'
    }

    def protocolConfig(TransportProtocolMQTTv5 protocol) {
        'mqtt:
            port: ${protocol.port}'
    }
 
    def main(Configuration config, FileArtifact target, mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes) {
        '${protocolConfig(config)}'
        'metricsprovider:
            schedulerrate: 3000
            memorybaseunit: kilobytes
            diskbaseunit: megabytes
        management:
            health:
                binders:
                    enabled: true
            endpoints:
                web:
                    exposure:
                        include: "metrics"
        spring:
            main:
                banner-mode: off
            cloud:
                function:
                    definition: ${function(nodes)}
                ${sources()}
                stream:
                    default:
                        contentType: application/iip
                    bindings:
                        ${bindings(mappedMesh)}'
    }

}